https://juejin.im/post/5e7ad1c0e51d450edc0cf053#heading-85

一：为什么要压缩APK 包大小

1.体积过大对 App 性能的影响
1）、安装时间过长：
2）、运行时内存过大

2、APK 组成

1）、代码相关：classes.dex，我们在项目中所编写的 java 文件，经过编译之后会生成一个 .class 文件，而这些所有的 .class 文件呢，它最终会经过 dx 工具编译生成一个 classes.dex。
2）、资源相关：res、assets、编译后的二进制资源文件 resources.arsc 和 清单文件 等等。
3）、So 相关：lib 目录下的文件，这块文件的优化空间其实非常大。




二、代码瘦身方案 

1、Dex 分析

 Dex 是 Android 系统的可执行文件，包含 应用程序的全部操作指令以及运行时数据。
Dex作用:当 Java 程序被编译成 class 文件之后，还需要使用 dx 工具将所有的 class 文件整合到一个 dex 文件中，
这样 dex 文件就将原来每个 class 文件中都有的共有信息合成了一体，这样做的目的是 保证其中的每个类都能够共享数据，这在一定程度上 降低了信息冗余，
同时也使得 文件结构更加紧凑。
Dex 一般在应用包体积中占据了不少比重，并且，Dex 数量越多，App 的安装时间也会越长。所以，优化它们可以说是 重中之重。下面，我们就来看看有哪些方式可以优化 Dex 这部分的体积。



2、ProGuard分析
为什么要使用代码混淆？

 Java 字节码 中包括了很多源代码信息，如变量名、方法名，并且通过这些名称来访问变量和方法，这些 符号带有许多语义信息，很 容易被反编译成 Java 源代码。为了防止这种现象，我们可以使用 Java 混淆器对 Java 字节码进行混淆。
混淆器的 作用 不仅仅是 保护代码，它也有 精简编译后程序大小 的作用，其 通过缩短变量和函数名以及丢失部分无用信息等方式，能使得应用包体积减小。


Proguard 的作用

    1）、瘦身：它可以检测并移除未使用到的类、方法、字段以及指令、冗余代码，并能够对字节码进行深度优化。最后，它还会将类中的字段、方法、类的名称改成简短无意义的名字。
    2）、安全：增加代码被反编译的难度，一定程度上保证代码的安全。


  1、压缩（Shrinking）

   默认开启，以减小应用体积，移除未被使用的类和成员， -dontshrink 关闭压缩

 2、优化（Optimization）
   默认开启，在 字节码级别执行优化，让应用 运行的更快。
   -dontoptimize 关闭优化
   -optimizationpasses n 表示proguard对代码进行迭代优化的次数，Android一般为5


 3、混淆（Obfuscation）
  默认开启，增大反编译难度，类和类成员会被随机命名，除非用 优化字节码 等规则进行保护。



Proguard 的配置


默认会在工程目录 app/build/outputs/mapping/release 下生成一个 mapping.txt 文件，这就是 混淆规则，所以我们可以根据这个文件把混淆后的代码反推回原本的代码。要使用混淆，我们只需配置如下代码即可：



buildTypes {
    release {
        // 1、是否进行混淆
        minifyEnabled true
        // 2、开启zipAlign可以让安装包中的资源按4字节对齐，这样可以减少应用在运行时的内存消耗
        zipAlignEnabled true
        // 3、移除无用的resource文件：当ProGuard 把部分无用代码移除的时候，
        // 这些代码所引用的资源也会被标记为无用资源，然后
        // 系统通过资源压缩功能将它们移除。
        // 需要注意的是目前资源压缩器目前不会移除values/文件夹中
        // 定义的资源（例如字符串、尺寸、样式和颜色）
        // 开启后，Android构建工具会通过ResourceUsageAnalyzer来检查
        // 哪些资源是无用的，当检查到无用的资源时会把该资源替换
        // 成预定义的版本。主要是针对.png、.9.png、.xml提供了
        // TINY_PNG、TINY_9PNG、TINY_XML这3个byte数组的预定义版本。
        // 资源压缩工具默认是采用安全压缩模式来运行，可以通过开启严格压缩模式来达到更好的瘦身效果。
        shrinkResources true
        // 4、混淆文件的位置，其中 proguard-android.txt 为sdk默认的混淆配置，
        // 它的位置位于android-sdk/tools/proguard/proguard-android.txt，
        // 此外，proguard-android-optimize.txt 也为sdk默认的混淆配置，
        // 但是它默认打开了优化开关。并且，我们可在配置混淆文件将android.util.Log置为无效代码，
        // 以去除apk中打印日志的代码。而 proguard-rules.pro 是该模块下的混淆配置。
        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        signingConfig signingConfigs.release
    }
}




三方库处理压缩

第三方库进行了统一  将图片加载库、网络库、数据库以及其他基础库进行统一，去掉冗余的库。

引入三方库的时候，可以 只引入部分需要的代码，而不是将整个包的代码都引入进来。

移除无用代码






三、资源瘦身方案探索





1、冗余资源优化  
 (1、)使用 Lint 的 Remove Unused Resource
APK 的资源主要包括图片、XML，与冗余代码一样，它也可能遗留了很多旧版本当中使用而新版本中不使用的资源，这点在快速开发的 App 中更可能出现
我们可以通过点击右键，选中 Refactor，然后点击 Remove Unused Resource => preview 可以预览找到的无用资源，点击 Do Refactor 可以去除冗余资源。

2、重复资源优化



3、图片压缩
  
 1. 使用使用 McImage、TinyPngPlugin 或 TinyPIC_Gradle_Plugin插件对APP中的图片进行自动化批量压缩。
  



四、So 瘦身方案探索(重点)(So：只保留 Armeabi、更优方案。)

Android 一共 支持7种不同类型的 CPU 架构，比如常见的 armeabi、armeabi-v7a、X86 等等。理论上来说，
对应架构的 CPU 它的执行效率是最高的，但是这样会导致 在 lib 目录下会多存放了各个平台架构的 So 文件，
所以 App 的体积自然也就更大了。

在 build.gradle 中配置这个 abiFiliters 去设置 App 支持的 So 架构

defaultConfig {
    ndk {
        abiFilters "armeabi"
    }
}







1、So 移除方案
2、So 移除方案优化版

3、使用 XZ Utils 对 Native Library 进行压缩
4、对 Native Library 进行合并
5、删除 Native Library 中无用的导出 symbol
6、So 动态下载













五、瘦身优化常见问题


1、怎么降低 Apk 包大小？
我们在回答的时候要注意一些 可操作的干货，同时注意结合你的 项目周期。主要可以从以下 三点 来回答：

1）、代码：Proguard、统一三方库、无用代码删除。
2）、资源：无用资源删除、资源混淆。
3）、So：只保留 Armeabi、更优方案。

在项目初期，我们一直在不断地加功能，加入了很多的代码、资源，同时呢，也没有相应的规范，所以说，UI 同学给我们很多 UI 图的时候，都是没有经过压缩的图片，长期累积就会导致我们的包体积越来越大。到了项目稳定期的时候，我们对各种运营数据进行考核，发现 APK 的包大小影响了用户下载的意愿，于是我们就着手做包体积的优化，我们采用的是 Android Studio 自带的 Analyze APK 来做的包体积分析，主要就是做了代码、资源、So 等三个方面的重点优化。
首先，针对于代码瘦身，第一点，我们首先 使用 Proguard 工具进行了混淆，它将程序代码转换为功能相同，但是不容易理解的形式。比如说将一个很长的类转换为字母 a，同时，这样做还有一个好处，就是让代码更加安全了。第二点呢，我们将项目中使用到的一些 第三方库进行了统一，比如说图片库、网络库、数据库等，不允许项目中出现功能相同，但是却实现不一样的库。同时也做了 规范，之后引入的三方库，需要去考量它的大小、方法数等，而且呢，如果只是需要一个很大库的一个小功能，那我们就修改源码，只引入部分代码即可。第三点，我们将项目中的 无用代码进行了删减，我们使用了 AOP 的方式统计到了哪些 Activity 以及 fragment 在真实的场景下没有用户使用，这样你就可以删除掉了。对于那些不是 Activity 或者是 Fragment 的类，我们切了很多类的构造函数，这样你就可以统计出来这些类在线上有没有真正被调用到。但是，对于代码的瘦身效果，实际上不是很明显。
接下来，我们做了资源的瘦身。首先，我们 移除了项目当中冗余的资源文件，这一点在项目当中一定会遇到。然后，我们做了 资源图片的压缩，UI 同学给我们资源图片的时候，需要确认已经是压缩过的图片，同时，我们还会做一个 兜底策略，在打包的时候，如果图片没有被压缩过，那我们就会再来压缩一遍，这个效果就非常的明显。对于资源，我们还做了 资源的混淆，也就是将冗余的资源名称换成简短的名字，资源压缩的效果要比代码瘦身的效果要好的多。
最后，我们做了 So 的瘦身。首先，我们只保留了 armeabi 这个目录，它可以 兼容别的 CPU 架构，这点的优化效果非常的明显。移除了对别的架构适配 So 之后，我们还做了另外一个处理，对于项目当中使用到的视频模块的 So，它对性能要求非常高，所以我们采用了另外一种方式，我们将所有这个模块下的 So 都放到了 armeabi 这个目录下，然后在代码中做判断，如果是别的 CPU 架构，那我们就加载对应 CPU 架构的 So 文件即可。这样即减少了包体积，同时又达到了性能最佳。最后，通过实践可以看出 So瘦身的效果一般是最好的。

 

2、Apk 瘦身如何实现长效治理？
主要可以从以下 两个方面 来进行回答：

1）、发版之前与上个版本包体积对比，超过阈值则必须优化。
2）、推进插件化架构改进。

在大型项目中，最好的方式就是 结合 CI，每个开发同学 在往主干合入代码的时候需要经过一次预编译，这个预编译出来的包对比主干打出来的包大小，如果超过阈值则不允许合入，需要提交代码的同学自己去优化去提交的代码。此外，针对项目的 架构，我们可以做 插件化的改造，将每一个功能模块都改造成插件，以插件的形式来支持动态下发，这样应用的包体积就可以从根本上变小了。

 

