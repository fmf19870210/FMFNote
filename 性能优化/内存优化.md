https://juejin.im/post/5e72b2d151882549236f9cb8


一、Android 内存管理机制
         
       1、内存泄漏的缘由
		Android系统的内存管理类似于JVM，通过new关键字来为对象分配内存，内存的释放由GC来回收。并且Android系统在内存管理上有一个 Generational Heap Memory模型，当内存达到某一个阈值时，系统会根据不同的规则自动释放可以释放的内存。
		即便有了内存管理机制，但是，如果不合理地使用内存，也会造成一系列的性能问题，比如 内存泄漏、内存抖动、短时间内分配大量的内存对象 等等。

       

      2、Java 内存分配模型

      1）、方法区：存储类信息、常量、静态变量等。=> 所有线程共享
      2）、虚拟机栈：存储局部变量 
      3）、本地方法栈：不同与虚拟机栈为 Java 方法服务、它是为 Native 方法服务的。native变量引用。
      4）、堆(匿名共享内存)：对象.内存最大的区域，每一个对象实际分配内存都是在堆上进行分配的，，而在虚拟机栈中分配的只是引用，这些引用会指向堆中真正存储的对象。此外，堆也是垃圾回收器（GC）所主要作用的区域，并且，内存泄漏也都是发生在这个区域。=> 所有线程共享
      5）、程序计数器：存储当前线程执行目标方法执行到了第几行。


      3、Android Runtime有两种虚拟机:Dalvik(<5.0) 和 ART(>5.0).它们分配的内存区域块是不同的
			    Dalvik :  仅固定一种回收算法。
			
			    Linear Alloc
			    Zygote Space
			    Alloc Space
			
			    ART :回收算法可运行期选择。  具备内存整理能力，减少内存空洞。
			
			    Non Moving Space
			    Zygote Space
			    Alloc Space
			    Image Space：存放一些预加载类
			    Large Obj Space:分配一些大对象，用于提高GC的管理效率和整体性能。






      4、Java 内存回收算法

         1）、标记-清除算法
			实现原理
		
		    标记出所有需要回收的对象。
		    统一回收所有被标记的对象。
           特点
           标记和清除效率不高。
		   产生大量不连续的内存碎片。
         2）、复制算法
			实现原理
			
			    将内存划分为大小相等的两块。
			    一块内存用完之后复制存活对象至另一块。
			    清理另一块内存。
			
			特点
			
			    实现简单，运行高效。
			    浪费一半空间，代价大。

			3）、标记-整理算法
			实现原理
			
			    标记过程与 ”标记-清除“ 算法一样。
			    存活对象往一端进行移动。
			    清理其余内存。
			
			特点
			
			    避免 ”标记-清除” 算法导致的内存碎片。
			    避免复制算法的空间浪费。

           4）、(新/老生代)分代收集算法（大多数虚拟机厂商所选用的算法）(重点)
				特点

			    结合多种收集算法的优势。
			    新生代对象存活率低 => “复制” 算法（注意这里每一次的复制比例都是可以调整的，如一次仅复制 30% 的存活对象）。
			    老年代对象存活率高 => “标记-整理” 算法。
			
      5、Android 内存回收机制


         在Android的高级系统版本中，针对堆Heap空间有一个Generational Heap Memory的模型，其中将整个内存分为三个区域：
         
          
 ![](https://user-gold-cdn.xitu.io/2020/3/19/170f0726be006da5?imageView2/0/w/1280/h/960/ignore-error/1) 
	      
          1. Young Generation（年轻代）
		        由一个Eden区和两个Survivor区组成，程序中生成的大部分新的对象都在Eden区中，当Eden区满时，还存活的对象将被复制到其中一个Survivor区，当此Survivor区满时，此区存活的对象又被复制到另一个Survivor区，当这个Survivor区也满时，会将其中存活的对象复制到年老代。
          2.Old Generation（年老代）
                 年老代中的对象生命周期都比较长。
	   
          3. Permanent Generation（持久代）
           用于存放静态的类和方法，持久代对垃圾回收没有显著影响。
              
         4、内存对象的处理过程小结

			1、对象创建后在Eden区。
			2、执行GC后，如果对象仍然存活，则复制到S0区。
			3、当S0区满时，该区域存活对象将复制到S1区，然后S0清空，接下来S0和S1角色互换。
			4、当第3步达到一定次数（系统版本不同会有差异）后，存活对象将被复制到Old Generation。
			5、当这个对象在Old Generation区域停留的时间达到一定程度时，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域。
		

D/dalvikvm(7030)：GC_CONCURRENT freed 1049K, 60% free 2341K/9351K, external 3502K/6261K, paused 3ms 3ms

	 

二、优化内存的意义


    1、减少OOM，提高应用稳定性。
    2、减少卡顿，提高应用流畅度。
    3、减少内存占用，提高应用后台运行时的存活率。
    4、减少异常发生和代码逻辑隐患。



三、避免内存泄漏

     常见内存泄漏场景
     1、资源性对象未关闭

      对于资源性对象不再使用时，应该立即调用它的close()函数，将其关闭，然后再置为null。例如Bitmap等资源未关闭会造成内存泄漏，此时我们应该在Activity销毁时及时关闭。

    2、注册对象未注销

      例如BraodcastReceiver、EventBus未注销造成的内存泄漏，我们应该在Activity销毁时及时注销。


    3、类的静态变量持有大数据对象

      尽量避免使用静态变量存储数据，特别是大数据对象，建议使用数据库存储。


    4、单例造成的内存泄漏

	优先使用Application的Context，如需使用Activity的Context，可以在传入Context时使用弱引用进行封装，然后，在使用到的地方从弱引用中获取Context，如果获取不到，则直接return即可。

   5、非静态内部类的静态实例
	该实例的生命周期和应用一样长，这就导致该静态实例一直持有该Activity的引用，Activity的内存资源不能正常回收。此时，我们可以将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，尽量使用Application Context，如果需要使用Activity Context，就记得用完后置空让GC可以回收，否则还是会内存泄漏。
 

	6、Handler临时性内存泄漏
	Message发出之后存储在MessageQueue中，在Message中存在一个target，它是Handler的一个引用，Message在Queue中存在的时间过长，就会导致Handler无法被回收。如果Handler是非静态的，则会导致Activity或者Service不会被回收。并且消息队列是在一个Looper线程中不断地轮询处理消息，当这个Activity退出时，消息队列中还有未处理的消息或者正在处理的消息，并且消息队列中的Message持有Handler实例的引用，Handler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。解决方案如下所示：
	
	1、使用一个静态Handler内部类，然后对Handler持有的对象（一般是Activity）使用弱引用，这样在回收时，也可以回收Handler持有的对象。
	2、在Activity的Destroy或者Stop时，应该移除消息队列中的消息，避免Looper线程的消息队列中有待处理的消息需要处理。
	


四、优化内存空间(重点)
     1. 对象引用
		      1、强引用
		
				如果一个对象具有强引用，GC就绝对不会回收它。当内存空间不足时，JVM会抛出OOM错误。
		
		      2、软引用
		
		        如果一个对象只具有软引用，则内存空间足够，GC时就不会回收它；如果内存不足，就会回收这些对象的内存。可用来实现内存敏感的高速缓存。
		
		
		     3、弱引用
		
				在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象
		
		     4、虚引用

    2、图片内存优化
     
       1、设置位图的规格：当显示小图片或对图片质量要求不高时可以考虑使用RGB_565，用户头像或圆角图片一般可以尝试ARGB_4444。通过设置inPreferredConfig参数来实现不同的位图规格
            BitmapFactory.Options options = new BitmapFactory.Options();
			options.inPreferredConfig = Bitmap.Config.RGB_565;
			BitmapFactory.decodeStream(is, null, options);

          
      2、inSampleSize：位图功能对象中的inSampleSize属性实现了位图的缩放功能
          BitampFactory.Options options = new BitmapFactory.Options();
		// 设置为4就是宽和高都变为原来1/4大小的图片
		options.inSampleSize = 4;
		BitmapFactory.decodeSream(is, null, options);
     3、inScaled，inDensity和inTargetDensity实现更细的缩放图片：当inScaled设置为true时，系统会按照现有的密度来划分目标密度

    	 BitampFactory.Options options = new BitampFactory.Options();
		options.inScaled = true;
		options.inDensity = srcWidth;
		options.inTargetDensity = dstWidth;
		BitmapFactory.decodeStream(is, null, options);

     

 3.其它的内存优化注意事项


尽使用static final 优化成员变量。
使用增强型for循环语法。
在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。
在合适的时候适当采用软引用和弱引用。
采用内存缓存和磁盘缓存。
尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。




五、图片管理模块的设计与实现


 实现三级缓存

1、内存缓存

3、磁盘缓存

由于磁盘读取时间是不可预知的，所以图片的解码和文件读取都应该在后台进程中完成。DisLruCache是Android提供的一个管理磁盘缓存的类。






============================================================================

深入探索 Android 内存优化（炼狱级别）

https://juejin.im/post/5e780257f265da575209652c
一:内存优化的纬度

对于Android内存优化来说又可以细分为如下两个维度，如下所示：

    1）、RAM优化
    2）、ROM优化
1、RAM优化

主要是 降低运行时内存。它的 目的 有如下三个：

    1）、防止应用发生OOM。
    2）、降低应用由于内存过大被LMK机制杀死的概率。
    3）、避免不合理使用内存导致GC次数增多，从而导致应用发生卡顿。
2、ROM优化
降低应用占ROM的体积，进行APK瘦身。它的 目的 主要是为了 降低应用占用空间，避免因ROM空间不足导致程序无法安装。
3、内存问题

那么，内存问题主要是有哪几类呢？  三类:

    1）、内存抖动
        当 内存频繁分配和回收 导致内存 不稳定，就会出现内存抖动，它通常表现为 频繁GC、内存曲线呈锯齿状。导致 页面卡顿，甚至造成 OOM
    2）、内存泄漏
对象被持有导致无法释放或不能按照对象正常的生命周期进行释放。可用内存减少、频繁GC，容易导致内存泄漏。
    3）、内存溢出OOM
 内存泄漏累积到一定程度导致OOM.
一次创建大的数组或者是载入大的文件如图片的时候会导致OOM.
很多OOM就是因图片处理不当 而产生的






二、内存抖动
1.什么是内存抖动?   
  当 内存频繁分配和回收 导致内存 不稳定，就会出现内存抖动，它通常表现为 频繁GC、内存曲线呈锯齿状。导致 页面卡顿，甚至造成 OOM

2、 为什么内存抖动会导致 OOM？


    1）、频繁创建对象，导致内存不足及碎片（不连续）。
    2）、不连续的内存片无法被分配，导致OOM。


3、内存抖动常见案例
   1、字符串使用加号拼接， 使用StringBuilder替代。
   2、减少不合理的对象创建  避免在循环中不断创建局部变量。




三、更深入的内存优化策略(重点)

 1、使 bitmap 资源在 native 中分配
对于 Android 2.x 系统，使用反射将 BitmapFactory.Options 里面隐藏的 inNativeAlloc 打开。
对于 Android 4.x 系统，使用或借鉴 Fresco 将 bitmap 资源在 native 中分配的方式。

 


2、图片加载时的降级处理(OOM可以try catch)
使用 Glide、Fresco 等图片加载库，通过定制，在加载 bitmap 时，若发生 OOM，
则使用 try catch 将其捕获，然后清除图片 cache，尝试降低 bitmap format（ARGB8888、RGB565、ARGB4444、ALPHA8）。


需要注意的是，OOM 是可以捕获的，只要 OOM 是由 try 语句中的对象声明所导致的，那么在 catch 语句中，是可以释放掉这些对象，解决 OOM 的问题的。
 
 
 
3.当应用使用的Service不再使用时应该销毁它，建议使用 IntentServcie。


4.谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。





四、内存问题总结(重点)

 1.把 WebView 类型的泄漏装进垃圾桶进程


 WebView  其 网络延时、引擎 Session 管理、Cookies 管理、引擎内核线程、HTML5 调用系统声音、视频播放组件等产生的引用链条无法及时打断，都会造成内存泄漏的问题
 解决方案:   把 WebView 装入另一个进程Activity里。
具体为在 AndroidManifes 中对当前的 Activity 设置 android:process 属性即可，
最后，在 Activity 的 onDestory 中退出进程，这样即可基本上终结 WebView 造成的泄漏。

 

2.在适当的时候对组件进行注销

在Activity创建的时候去注册一些组件，如广播、定时器、事件总线等等,在Activity的onPause 或 onDestory 方法中对组件进行注销,防止内存泄漏


3.图片放错资源目录也会有内存问题


做资源适配的时候，因为需要考虑到 APK 的瘦身问题,如果放到分辨率低的目录如 hdpi 目录，则可能会造成内存问题.
这个时候建议尽量问设计人员要高品质图片然后往高密度目录下方，如 xxhdpi 目录存放图片。



4.列表 item 被回收时注意释放图片的引用




5.针对匿名内部类 Runnable 造成内存泄漏的处理  


五、内存优化常见问题
1、你们内存优化项目的过程是怎么做的？

