


一:自定义View基础 - 最易懂的自定义View原理系列

 https://www.jianshu.com/p/146e5cec4863




	1.View类简介

   View的构造函数：共有4个，具体如下：
// 如果View是在Java代码里面new的，则调用第一个构造函数
//Context - View中随处都会用到。
 public CarsonView(Context context) {
        super(context);
    }

// 如果View是在.xml里声明的，则调用第二个构造函数
// 自定义属性是从AttributeSet参数传进来的
//AttributeSet - XML属性（当从XML inflate的时候）
    public  CarsonView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

// 不会自动调用
// 一般是在第二个构造函数里主动调用
// 如View有style属性时
//int defStyleAttr - 应用到View的默认风格（定义在主题中）。
    public  CarsonView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    //API21之后才使用
    // 不会自动调用
    // 一般是在第二个构造函数里主动调用
    // 如View有style属性时
    public  CarsonView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }






2. View视图结构

 
![](https://upload-images.jianshu.io/upload_images/944365-afb2be431e523baf.png?imageMogr2/auto-orient/strip|imageView2/2/w/530)

一定要记住：无论是measure过程、layout过程还是draw过程，永远都是从View树的根节点开始测量或计算（即从树的顶端开始），一层一层、一个分支一个分支地进行（即树形递归），最终计算整个View树中各个View，最终确定整个View树的相关属性。

 


3. Android坐标系

  (1)Android的坐标系定义为：

  ![](https://upload-images.jianshu.io/upload_images/944365-ee0cd39fd788e293.png?imageMogr2/auto-orient/strip|imageView2/2/w/336)

    屏幕的左上角为坐标原点
    向右为x轴增大方向
    向下为y轴增大方向

  (2) View位置（坐标）描述

  ![](https://upload-images.jianshu.io/upload_images/944365-398c610a464cbdc8.png?imageMogr2/auto-orient/strip|imageView2/2/w/437)

  ![](https://upload-images.jianshu.io/upload_images/944365-2fb2682c45d05ff9.png?imageMogr2/auto-orient/strip|imageView2/2/w/437)

 4个顶点的位置描述分别由4个值决定：
（请记住：View的位置是相对于父控件而言的）

    Top：子View上边界到父view上边界的距离  子View左上角距父View顶部的距离；
    Left：子View左边界到父view左边界的距离  子View左上角距父View左侧的距离； 
    Bottom：子View下边距到父View上边界的距离  子View右下角距父View顶部的距离
    Right：子View右边界到父view左边界的距离  子View右下角距父View左侧的距离
	  
View的位置是通过view.getxxx()函数进行获取：   
 public final int getTop(); // 获取Top位置
 public final int getLeft(); //获取子View左上角距父View左侧的距离
 public final int getBottom(); //获取子View右下角距父View顶部的距离
  public final int getRight();  //获取子View右下角距父View左侧的距离
  
 
 与MotionEvent中 get()和getRaw()的区别
//get() ：触摸点相对于其所在组件坐标系的坐标
 event.getX();       
 event.getY();

//getRaw() ：触摸点相对于屏幕默认坐标系的坐标
 event.getRawX();    
 event.getRawY();

 ![](https://upload-images.jianshu.io/upload_images/944365-e50a2705cdd632d3.png?imageMogr2/auto-orient/strip|imageView2/2/w/331)




自定义View Measure过程

https://www.jianshu.com/p/1dab927b2f36


一:预先需要了解的知识点:

 (1) ViewGroup.LayoutParams类（） 布局参数类,指定视图View 的高度（height） 和 宽度（width）等布局参数。







 (2) MeasureSpecs 类（父视图对子视图的测量要求）
    1.MeasureSpec 被封装在View类中的一个内部类里：MeasureSpec类
     测量规格（MeasureSpec） = 测量模式（mode） + 测量大小（size）
     该措施的目的 = 减少对象内存分配
 ![](https://upload-images.jianshu.io/upload_images/944365-7d0f873cee3912bb.png?imageMogr2/auto-orient/strip|imageView2/2/w/380)

   2.MeasureSpec类的具体使用
    // 1.通过measureSpec的getMode（）方法获得测量模式（mode）
    int specMode = MeasureSpec.getMode(measureSpec)

    // 2.通过measureSpec的getSize方法获得测量大小 （Size）
    int specSize = MeasureSpec.getSize(measureSpec)

    // 3.   根据提供的size和mode得到一个详细的测量结果吗，即measureSpec
       int measureSpec=MeasureSpec.makeMeasureSpec(size, mode);
           public static int makeMeasureSpec(int size, int mode) {  
             // measureSpec = size + mode；此为二进制的加法 而不是十进制
                return size + mode;  
             }  

   

   3.子View的MeasureSpec值到底是如何计算得来?

   ![](https://upload-images.jianshu.io/upload_images/944365-d059b1afdeae0256.png?imageMogr2/auto-orient/strip|imageView2/2/w/470)
  
   
   1.子view的宽高大小=子view的布局参数LayoutParams+父view的MeasureSpec值
   注：子view的大小由父view的MeasureSpec值 和 子view的LayoutParams属性 共同决定

   2.源码分析:略

   3.其中的规律总结：（以子View为标准，横向观察）
    
   ![](https://upload-images.jianshu.io/upload_images/944365-6088d2d291bbae09.png?imageMogr2/auto-orient/strip|imageView2/2/w/660)







 三:measure过程详解
    measure过程 根据View的类型分为2种情况：
    1. 单一View的measure过程
         测量流程: 入口:measure()  -> onMeasure() -> setMeasureDimension() -> getDefaultSize() ->完成测量
     
        
  ![](https://upload-images.jianshu.io/upload_images/944365-2ba9801fcad2b48c.png?imageMogr2/auto-orient/strip|imageView2/2)


    2. ViewGroup的measure过程
   
    遍历 测量所有子View的尺寸
    合并将所有子View的尺寸进行，最终得到ViewGroup父视图的测量值
   ![](https://upload-images.jianshu.io/upload_images/944365-1438a7fbd93d0987.png?imageMogr2/auto-orient/strip|imageView2/2/w/569)


   测量ViewGroup步骤流程:

    第一步： 入口 = measure（），进行自定义ViewGroup，则需重写onMeasure()
    
 
 
    /**
  * 源码分析：measure()
  * 作用：基本测量逻辑的判断；调用onMeasure()
  * 注：与单一View measure过程中讲的measure()一致
  **/ 
  public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
    ...
    int cacheIndex = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 :
            mMeasureCache.indexOfKey(key);
    if (cacheIndex < 0 || sIgnoreMeasureCache) {

        // 调用onMeasure()计算视图大小
        onMeasure(widthMeasureSpec, heightMeasureSpec);
        mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
    } else {
        ...
}

 


第二步:自定义ViewGroup中,复写onMeasure()从而实现你的子View测量逻辑

  复写onMeasure（） ——>遍历所有子View & 测量：measureChildren（）, 遍历所有子view, 调用 measureChild(child, widthMeasureSpec, heightMeasureSpec)进行下一步的测量, 计算单个子View的MeasureSpec， 测量每个子View最后的宽 / 高：调用子View的measure() 
(ViewGroup无法对onMeasure（）作统一实现。这个也是单一View的measure过程与ViewGroup过程最大的不同。
因为不同的ViewGroup子类（LinearLayout、RelativeLayout / 自定义ViewGroup子类等）具备不同的布局特性，
 这导致他们子View的测量方法各有不同)
   --->








四:LinearLayout的measure过程实例解析 


 1.直接进入LinearLayout复写的onMeasure（）

-->测量LinearLayout垂直方向的测量尺寸  measureVertical(int widthMeasureSpec, int heightMeasureSpec)/
    测量LinearLayout水平方向的测量尺寸 measureHorizontal(widthMeasureSpec, heightMeasureSpec);


-->  获取垂直方向上的子View个数:    final int count = getVirtualChildCount();

   
-->调用measureChildren（）  遍历所有子View & 测量：measureChildren（）

-->存储测量后View宽/高的值：调用setMeasuredDimension()  setMeasureDimension(resolveSizeAndState(maxWidth,width))







====================================================================================================================================================
自定义View Layout过程


  一. 单一View的layout过程
   1.  layout过程的入口 = layout（）
   2.由于单一View是没有子View的，故onLayout（）是一个空实现
     由于在layout（）中已经对自身View进行了位置计算，所以单一View的layout过程在layout（）后就已完成了

![](https://upload-images.jianshu.io/upload_images/944365-756f72f8ccc58d2c.png?imageMogr2/auto-orient/strip|imageView2/2/w/310)





  二:ViewGroup的layout过程



    1.计算自身ViewGroup的位置：layout（）
    2.遍历ViewGroup的子View & 确定自身子View在ViewGroup的位置（调用子View 的 layout（））：onLayout（）

	    (此处需注意：
	    ViewGroup 和 View 同样拥有layout（）和onLayout()，但二者不同的：
	
	    一开始计算ViewGroup位置时，调用的是ViewGroup的layout（）和onLayout()；
	    当开始遍历子View & 计算子View位置时，调用的是子View的layout（）和onLayout()
	    )
![](https://upload-images.jianshu.io/upload_images/944365-7ebd03609c758d47.png?imageMogr2/auto-orient/strip|imageView2/2/w/498)









 三:实例讲解:LinearLayout的layout过程


四: 自定义View 实现layout 的过程

  1.计算出ViewGroup在父布局的位置   layout()
  
  2.计算出ViewGroup中子View在容器中的位置  onLayout()


  3.  遍历所有的子view  测量所有的子view 的摆放位置  setFrame()方法
    

 注意区分:       
getWidth() （ getHeight()）与 getMeasuredWidth() （getMeasuredHeight()）获取的宽 （高）有什么区别？


  getWidth() / getHeight()：获得View最终的宽 / 高
  getMeasuredWidth() / getMeasuredHeight()：获得 View测量的宽 / 高

 



五:总结

  ![](https://upload-images.jianshu.io/upload_images/944365-bb11305f1e40a8fb.png?imageMogr2/auto-orient/strip|imageView2/2/w/560)

  ![](https://upload-images.jianshu.io/upload_images/944365-6baebb31c56040dc.png?imageMogr2/auto-orient/strip|imageView2/2/w/970)

 




=========================================================================================
自定义View Draw过程


 一: 单一View的draw过程

    
   1.绘制步骤:
  
      draw过程的入口 = draw(Canvas canvas):根据给定的 Canvas 自动渲染 View（包括其所有子 View）。
       步骤1： 绘制本身View背景    drawBackground(canvas);  
             (根据在 layout 过程中获取的 View 的位置参数，来设置背景的边界 setBackgroundBounds(); )
       步骤2：绘制本身View内容     onDraw(canvas); 

       步骤3：绘制子View  dispatchDraw(canvas)  由于单一View无子View，故View 中：默认为空实现
        


      步骤4：绘制装饰，如滑动条、前景色等等 onDrawScrollBars(canvas);   



   2. 图解:

   ![](https://upload-images.jianshu.io/upload_images/944365-b63b64086782a217.png?imageMogr2/auto-orient/strip|imageView2/2/w/330)



二：ViewGroup的draw过程

   绘制步骤:

    1. ViewGroup绘制自身（含背景、内容）；
          draw过程的入口 = draw(Canvas canvas)  到此 继续
              (1). 绘制view背景     drawBackground(canvas);
		      (2). 绘制view内容      onDraw(canvas);
		      (3). 遍历子View & 绘制子View        dispatchDraw(canvas);
		      (4). 绘制装饰（渐变框，滑动条等等） onDrawScrollBars(canvas);

 
    2.ViewGroup遍历子View & 绘制其所有子View；
    3. ViewGroup绘制装饰（滚动指示器、滚动条、和前景）

 