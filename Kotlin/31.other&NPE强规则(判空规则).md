

companion object有什么好处
companion object的好处是，外部类可以直接访问对象，不需要通过对象指针





kotlin中访问对象的形式有哪些？


kotlin中有哪些方式可以实现单利模式？

第一种方式

class SchedulerProvider {

    //companion object的好处是，外部类可以直接访问对象，不需要通过对象指针
    companion object {
        private var mInstance: SchedulerProvider? = null
        fun getInstance(): SchedulerProvider? {
            if (mInstance == null) {
                synchronized(SchedulerProvider::class) {
                    if (mInstance == null) {
                        mInstance = SchedulerProvider()
                    }
                }
            }
            return mInstance
        }
    }
    //省略部分代码
}

//如何调用
scheduler = SchedulerProvider.getInstance()
scheduler?.applySchedulers()

//注意，这里获取单利对象，通过单利对象调用其他方法需要添加?做非空判断，因为SchedulerProvider?







    第二种方式

//Kt文件中的声明方式： object 关键字声明,其内部不允许声明构造方法
object SingleObject {
    fun getApp(): Application {
        if (Utils.getApp()!=null){
            return Utils.getApp()
        }
        throw NullPointerException("u should init first")
    }
}

//如何调用
content = AndroidUtils.SingleObject.getApp()
content.resources.getDimensionPixelOffset(R.dimen.dp1)






什么是半生类对象，在使用时需要注意什么问题？

    伴生对象通过在类中使用companion object来创建，用来替代静态成员，类似于Java中的静态内部类。所以在伴生对象中声明常量是很常见的做法，但如果写法不对，可能就会产生额外开销。






!! 强行转为非空的使用注意事项有哪些？

    当将可空类型赋值给非空类型时，需要有对空类型的判断，确保非空才能赋值（Kotlin 的约束）。使用!! 可以很方便得将“可空”转为“非空”，但可空变量值为 null，则会 crash。
    因此使用上建议在确保非空时才用 !!: param!!
    否则还是尽量放在判空代码块里:

param?.let {
   doSomething(it)
}





在Kotlin中有3种数组类型：

var a : IntArray = IntArray(4)  //IntArray，FloatArray，其他：基本类型数组，被编译成int[]，float[]，
var b : Array<Int> = arrayOf(4)   //Array：非空对象数组
var c : Array<Int?> = arrayOf(null)  //Array：可空对象数组

等同于Java代码如下所示
private final int[] a = new int[4];
private final Integer b = new Integer(Integer.valueOf(4));
private final Integer c = new Integer((Integer)null);




by lazy的作用是什么？lazy使用场景有哪些？by lazy和lateinit的区别有哪些？




kotlin中异常是如何处理的？
kotlin中异常是如何处理的
 和Java类似，一种是throw，另一种是try……catch


fun compute(index: Int): Boolean {
    if (index !in 0..10) {
        throw IllegalArgumentException("参数错误")
    }
    return true
}

















01.Java中判断方式
1.1 防御式编程  “防御式编程”大家应该不陌生，核心思想是不信任任何“外部”输入,进行各种判空

1.2 契约式编程

02.kotlin中判空


2.1 kotlin如何约束非空判断
声明阶段
变量需要决定自己是否可为空,加?
private var goodsId: String ?= null
 private var goodsId2: String=""

 传递阶段
在变量传递阶段中，必须保持“可空性”一致性
 形参声明是不为空,实参必须本身也不为空
















