




03.抽象类(不需要用 open 标注一个抽象类或者抽象方法)
abstract class BaseClass {
    abstract fun fun1()
}

class Derived : BaseClass() {
    override fun fun1() {

    }
}




04.嵌套类

在类里面再定义的类默认是嵌套类，此时嵌套类不会包含对外部类的隐式引用

class Outer {

    private val bar = 1

    class Nested {
        fun foo1() = 2
        //错误
        //fun foo2() = bar
    }
}

fun main(args: Array<String>) {
    val demo = Outer.Nested().foo1()
}



 java  代码

public final class Outer {
   private final int bar = 1;

   public static final class Nested {
      public final int foo1() {
         return 2;
      }
   }
}

public final class MainKotlinKt {
   public static final void main(@NotNull String[] args) {
      Intrinsics.checkParameterIsNotNull(args, "args");
      int demo = (new Outer.Nested()).foo1();
   }
}









05.匿名内部类


06.内部类
class Outer {

    private val bar = 1

    inner class Nested {
        fun foo1() = 2
        fun foo2() = bar
    }
}

fun main(args: Array<String>) {
    val demo = Outer().Nested().foo2()
}




06.kotlin单利模式
kotlin的单例只需要一个object 关键字即可,其内部不允许声明构造方法



object 对象名SingleObject {

//init代码块对应java中static代码块
init{ LogUtils.e("DataProviderManager"+"init")}
fun test() {}
fun registerDataProvider(provider: String) {
        LogUtils.e("DataProviderManager$provider")
    }
}



 调用方式


 class Main {
     fun test() {
         SingleObject.test() //在class文件中，会自动编译成SingleObject.INSTANCE.test();调用方式
         SingleObject.registerDataProvider("")
     }
 }


















