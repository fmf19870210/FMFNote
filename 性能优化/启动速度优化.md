![](https://user-gold-cdn.xitu.io/2020/3/26/17115ecebc3f55e6?imageView2/0/w/1280/h/960/ignore-error/1)




一:应用启动的类型

 
1.冷启动：从点击应用图标到UI界面完全显示且用户可操作的全部过程。耗时最多.
2.热启动:直接从后台切换到前台。 启动速度最快。
3.温启动：只会重走Activity的生命周期，而不会重走进程的创建，Application的创建与生命周期等。
     较快，介于冷启动和热启动之间的一个速度。



二:  冷启动启动流程
Click Event    ->   用户进行了一个点击操作
   IPC     ->   点击事件它会触发一个IPC的操作
   Process.start     ->   执行创建进程方法
  ActivityThread ->  执行ActivityThread的main方法,开启我们单个App进程的入口。会执行消息循环的创建与主线程Handler的创建
  bindApplication      ->  执行到 bindApplication 方法，调用了 Application相关的生命周期
  LifeCycle    ->   执行Activity的生命周期  
 ViewRootImpl ->执行到 ViewRootImpl.这时才会进行真正的一个页面的绘制。
                一个ViewRootImpl关联一个Window， ViewRootImpl 最终会通过它的setView方法绑定Window所对应的View，并通过其performTraversals方法对View进行布局、测量和绘制。

 

三:冷启动要做的流程:
 
1. Launcher startActivity
2.AMS startActivity
3.Zygote fork 进程
4.ActivityThread main()
4.1.  ActivityThread attach
4.2. handleBindApplication
4.3  attachBaseContext (需要优化的)
4.4. installContentProviders
4.5. Application onCreate (需要优化的)
5.ActivityThread 进入loop循环
6.Activity生命周期回调，onCreate、onStart、onResume... (需要优化的)

 





四、启动优化常规方案

1.第三方库懒加载：等到用时才进行加载。
今日头条的MultiDex优化方案：

在Application 的attachBaseContext 方法里，启动另一个进程的LoadDexActivity去异步执行MultiDex逻辑，显示Loading。
然后主进程Application进入while循环，不断检测MultiDex操作是否完成
MultiDex执行完之后主进程Application继续走，ContentProvider初始化和Application onCreate方法，也就是执行主进程正常的逻辑。
 

2.线程优化:
设置线程优先级,干预线程调度级别顺序
线程是程序运行的基本单位，线程的频繁创建是耗性能的，所以大家应该都会用线程池。
单个cpu情况下，即使是开多个线程，同时也只有一个线程可以工作，所以线程池的大小要根据cpu个数来确定。







3.Android常用的异步线程

 (1)IntentService线程:

    继承自Service在内部创建HandlerThread。
    异步，不占用主线程。
    优先级较高，不易被系统Kill。

(2)线程池（合理配置并选择CPU密集型和IO密集型线程池）
    Java提供的线程池。
    易复用，减少频繁创建、销毁的时间。
    功能强大，如定时、任务队列、并发数控制等



 4.线程池的优化
    线程过多的导致的问题:异步任务执行太耗时，导致主线程卡顿。没有区分IO和CPU密集型任务，导致主线程抢不到CPU。Java线程调度是抢占式的，线程优先级比较重要，需要区分。
 

 

5.Multidex预加载优化（本文重点）
  
![](https://user-gold-cdn.xitu.io/2019/10/7/16da4e5b011026c4?imageView2/0/w/1280/h/960/ignore-error/1)

MultiDex优化方案：今日头条方案   https://github.com/lanshifu/MultiDexTest/

![](https://user-gold-cdn.xitu.io/2019/10/7/16da4e5b1001b493?imageView2/0/w/1280/h/960/ignore-error/1)
![](https://user-gold-cdn.xitu.io/2019/10/7/16da4e5b3cc1e5b6?imageView2/0/w/1280/h/960/ignore-error/1)


今日头条的MultiDex优化方案：

在Application 的attachBaseContext 方法里，启动另一个进程的LoadDexActivity去异步执行MultiDex逻辑，显示Loading。
然后主进程Application进入while循环，不断检测MultiDex操作是否完成
MultiDex执行完之后主进程Application继续走，ContentProvider初始化和Application onCreate方法，也就是执行主进程正常的逻辑。
 

6.IO优化



7.WebView优化   mp.weixin.qq.com/s/KwvWURD5W…  

WebView第一次创建比较耗时，可以预先创建WebView，提前将其内核初始化。
使用WebView缓存池，用到WebView的地方都从缓存池取，缓存池中没有缓存再创建，注意内存泄漏问题。
本地预置html和css，WebView创建的时候先预加载本地html，之后通过js脚本填充内容部分。

 



8. 闪屏页优化
消除启动时的白屏/黑屏，市面上大部分App都采用了这种方法，不会缩短实际冷启动时间


    <application
    android:name=".MainApplication"
    ...
    android:theme="@style/AppThemeWelcome>

<style name="AppThemeWelcome" parent="Theme.AppCompat.NoActionBar">
    ...
    <item name="android:windowBackground">@drawable/logo</item>  <!-- 默认背景-->
</style>

   <activity android:name=".ui.activity.DemoSplashActivity"
            android:configChanges="orientation|screenSize|keyboardHidden"
            android:theme="@style/AppThemeWelcome"
            android:screenOrientation="portrait">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

protected void onCreate(@Nullable Bundle savedInstanceState) {
    setTheme(R.style.AppTheme); //切换正常主题
    super.onCreate(savedInstanceState);

 


9.数据预加载

 这种方式一般是在主页空闲的时候，将其它页面的数据加载好，保存到内存或数据库，等到打开该页面的时候，判断已经预加载过，直接从内存或数据库读取数据并显示。