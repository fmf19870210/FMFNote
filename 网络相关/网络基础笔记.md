

一:网络体系结构

   ![](https://camo.githubusercontent.com/5bf7c14046570425f50bca412a3cf3710514ccff/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542412539342545352542312538322545342542442539332545372542332542422545372542422539332545362539452538342e706e67)

1.分层

 ![](https://camo.githubusercontent.com/62a81cdf1d9840226e1a49625e5821f17e655cfd/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542382538332545352542312538322545342542442539332545372542332542422545372542422539332545362539452538342545352539422542452e706e67)

	应用层(应用层,表示层,会话层) application-layer:      应用层协议定义的是应用进程间的通信和交互的规则。对于不同                         												  的网络应用需要不同的应用层协议。(如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮           												  件的 SMTP协议等等)  
	传输层(传输层) transport layer ：提供通用的数据传输服务          分TCP(可靠)和UDP(不可靠)两种协议运输
	网络层(网络层)      （IP等） 规划网络地址  IP层协议,指定了数据要传输到哪个IP地址
	数据链路层(数据链路层)  data link layer （ARP等）  ARP协议  硬件地址.找到了对应的唯一的机器。
	物理层(物理层) physical layer   最底层  提供二进制流传输服务


   



二:TCP和UDP详细介绍

 TCP协议： 
     可靠
    必须建立连接，形成传输数据的通道
    在连接中可进行大数据量传输,不丢失数据
    通过三次握手完成连接，是可靠协议
    必须建立连接，效率会稍低


UDP协议：QQ 语音、 QQ 视频 、直播
    不可靠
    面向无连接
    每个数据报的大小在限制在64k内
    因为是面向无连接，所以是不可靠协议,会丢失数据
    不需要建立连接，速度快




三:UDP协议传输数据

     UDP客户端发送数据流程:
       1.创建发送端Socket对象
       2.创建数据，并把数据打包
       3.调用Socket对象发送方法发送数据包
       4.释放资源
      UDP服务端接收数据
        1.创建接收端Socket对象
        2.创建一个数据包(接收容器)
        3.调用Socket对象接收方法接收数据包
        4.解析数据包
        5.释放资源



四:TCP协议传输数据
     TCP客户端发送数据:
     1.创建socket并指定ip和端口号
     2.获取输出流，写数据
     3.释放资源   

    TCP服务端接收数据:
      1.创建接收端的Socket对象
      2.监听客户端接收，返回一个Socket对象
      3.获取输入流，读取数据显示在控制台
      4.释放资源 




五:三次握手建立连接流程

         5.1 三次握手流程图  


![](https://camo.githubusercontent.com/ce8b8f1b3c8d2fbe9e5798ceeef0f67e4725fe3a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542382538392545362541432541312545362538462541312545362538392538422e706e67) 
       
![](https://camo.githubusercontent.com/f6dfce1f05e95f94dbcc4b0bee8c4e3acbfb9f30/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67)

     三次握手流程:
      客户端–发送带有 SYN 标志的数据包–一次握手–服务端
      服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
      客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端
      

       5.2 为什么建立连接需要三次握手?
        原因: 三次握手的目的是建立可靠的通信信道，三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。
 
  
		第一次握手，C端发了个连接请求消息到S端，S端收到后S端就知道自己与C端是可以连接成功的
		第二次握手，C端此时并不知道S端是否接收到这个消息，所以S端接收到消息后就会想C端进行应答，C端得到S端的回复后，才能确定自己与S端是成功连接上的，这就是第二次握手。
        第三次握手是为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误
         两次握手会造成S端傻傻的等待C端发送数据来,造成资源的浪费,所以需要第三次握手,需要C端再次回应一下,S端关闭服务

         
		
 



        5.3 为什么会有四次握手?
        S端(服务端)会发送二次握手给哭护短,一次握手ACK回复C端消息数据,   二次握手FIN 回复C端终止消息（断开一个 TCP 连接则需要“四次挥手”）
      
          
			举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

 

![](https://camo.githubusercontent.com/66e3447783e22d736f7db9c7d121e8eba54f07c0/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f5443502545352539422539422545362541432541312545362538432541352545362538392538422e706e67)



六:
 链接:https://mp.weixin.qq.com/s/DGIkZT26CBafJzpQgrqqdQ
二:什么是对称加密?什么是非对称加密?

对称加密:对称加密的优点是加解密效率高,密钥存放在客户端有被窃取的风险。对称加密的代表算法有：AES、DES等
优点: 加密效率高 计算量小
缺点: 秘钥写死在客户端很容易泄露,导致整个加密系统崩塌。所以需要后台不断的更新变化秘钥。

   ![](https://raw.githubusercontent.com/fmf19870210/FMFNote/master/image/QQ20200304160356.png)   
  
 
非对称加密:公钥和私钥。公钥通常存放在客户端，私钥通常存放在服务器.公钥加密的数据只有用私钥才能解密,使用私钥加密的数据也只有用公钥才能解密.客户端发送给服务器的加密信息只有用服务器的私钥才能解密.非对称加密的代表算法有：RSA、ElGama.

 优点: 公钥公开的 ,私钥存储到服务端，安全高
 缺点: 性能差,使用复杂



 
 常用的加密技术分类

  哈希函数: SHA256  MD5
  对称加密:AES  DES
  非对称加密: RSA  ECC 
  秘钥交换: DH
  


 

 




七: HTTP1.0、HTTP1.1 和 HTTP2.0 的区别


 https://juejin.im/entry/5981c5df518825359a2b9476

 
  一: HTTP的结构

   Request Headers   客户端给服务器发送了那些参数：
        Accept-Encoding:gzip 
        Accept-Language： zh-cn 
        cache-control： max-age=0;  指定缓存机制  
        cookie： 缓存在本地
      
 


 二:  HTTP1.0和HTTP1.1的一些区别(重点)
       
      
     1.缓存处理的不同:
         HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准
         HTTP1.1则引入了更多的缓存控制策略(Entity tag，If-Unmodified-Since, If-Match, If-None-Match)
        
     2.带宽优化及网络连接的使用的不同:
         HTTP1.0中，存在一些浪费带宽的现象。

     3.错误通知的管理 
        HTTP1.1中新增了24个错误状态响应码



     4.  Host头处理
        
                  
     5.长连接的不同
        HTTP 1.0 只支持一个请求链接,
        HTTP 1.1支持长连接  ,可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟
    


     


 三: Http2.0 与HTTP1.X的区别:
      
   
   1. 传输协议不同 
            http1.1   文本协议传输 。  由于 文本的表现形式有多样性,需要考虑多种场景，具有缺陷性；
           Http2.0    二进制则 传输协议 ,实现方便且健壮 。


   2.多路复用不同
             HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接,很好性能；
             HTTP2.0  多个不同请求可同时共用一个连接,同时并行执行请求； 提升性能,降低损耗,提升性能。
          某个请求任务耗时严重，不会影响到其它连接的正常执行；
 
        



  
    3.   header头部压缩的不同
          HTTP1.x的header带有大量信息，而且每次都要重复发送
           HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。大大降低因头部传输产生的流量

          (为什么需要头部压缩？
             

            )



 

HTTP1.x  使用SPDY : 
                   (1)SPDY采取了多路复用 ,共用同一个tcp连接,提高了带宽的利用率
                   (2)SPDY设置请求优先级（request prioritization）,重要的请求request就会优先得到响应。
                    多路复用,在连接共享的基础之上有可能会导致关键请求被阻塞.SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
                    (3)SPDY采用压缩算法可以减小包的大小和数量
                        
                    (4)基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。





四:Http与Https区别
      
         
         1.Http协议只是一个超文本传输协议，信息是明文传输。 无连接: 每次连接只处理一个请求，一次请求完成后就断开连接,主要是为了缓解服务器的压   力，减小连接对服务器资源的占用。
       
	     Https    是具有安全性的非对称的ssl加密传输协议。 Https=Http+Ssl,Https保证了我们数据传输的安全,主要就是利用了非对称加密算法SSL(公钥加密的信息只能用私钥解开，私钥加密的信息只能被公钥解开)

            




  


五: 关于证书Certificate的解释:

![](https://upload-images.jianshu.io/upload_images/4264145-9fc7b334fca31e8d.png?imageMogr2/auto-orient/strip|imageView2/2/w/662)
  







六:常见的加密方式:
https://juejin.im/post/5b48b0d7e51d4519962ea383#heading-23
https://github.com/yangchong211/YCBlogs/blob/master/android/%E7%BB%8F%E5%85%B8%E6%80%BB%E7%BB%93/04.%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86.md

1. 对称加密
(1)定义:通信双方(加密和解密)使用同一个密钥
 

 ![](https://upload-images.jianshu.io/upload_images/4264145-0e4f865df41a9358.png?imageMogr2/auto-orient/strip|imageView2/2/w/659)

 (2) DES  3DES  AES(128位、192位、256位密钥)
   

 (3)缺点:密钥泄漏：不能再不安全网络上传输密钥，一旦密钥泄漏则加密通信失败


2. 非对称加密

(1)定义:使用公钥对数据进行加密得到密文，使用私钥对密文数据进行解密得到原数据
     公钥可以公开   私钥不能公开

         非对称加密算法SSL安全的原理:
         服务端申请CA机构颁发的证书，则获取到了证书的公钥和私钥，私钥只有服务器端自己知道,公钥传给客户端,
         客户端传递给服务端的数据通过公钥进行加密,而这个公钥加密的数据 只有服务端的私钥才能解密,这样就确保了数据传输的安全性。

           SSL（Secure Socket Layer，安全套接字层）
           SSL 由 Netscape 公司所研发，用以保障在 Internet 上数据传输之安全，利用数据加密 (Encryption) 技术，可确保数据在网络上传输过程中不会被截取。
           SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。

  

  ![](https://upload-images.jianshu.io/upload_images/4264145-075be72154b53fdb.png?imageMogr2/auto-orient/strip|imageView2/2/w/550)

  ![](https://camo.githubusercontent.com/ea181336de325fb712fc5216d04487172f3f7da6/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f343433323334372d336161653635653063633430626636622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)


(2)RSA(可用于加密和签名)、DSA(仅用于签名，但是速度更快)

(3)非对称加密的优缺点

    优点：可以在不安全网络上传输密钥
    缺点：计算复杂，因此性能相比对称加密差很多

 


       






3.HASH算法

 (1)定义:把任意数据转换成指定大小范围（通常很小，例如256字节以内）的数据。
        HASH不是编码 不是加密 是单向过程   不可逆   常见如:MD5  SHA

 (2)经典HASH算法:MD5, SHA1, SHA256


 (3)Hash是实际用途：
     唯一性验证:
     数据完整性验证：下载文件进行hash，通过对比原文件的hash值，就可以确认是否下载受损。 
     快速查找：HashMap就能进行快速查找
     数据保护：对于登录时的密码进行hash，然后数据库中也是储存密码的hash值，这样只要对比hash值就可以判断密码是否正确。

 (4)Hash不是编码,不是加密,Hash是一个单向过程，往往不可逆
     编码:把数据由一种数据格式转换成另一种数据格式,是可逆的，比如压缩解压缩就是编码的一种。







4.数字签名

     (1)定义:简单来说就是通过提供 可鉴别 的 数字信息 验证 自身身份 的一种方式。





5.Base64编码算法
 定义:将二进制数据转换成由64个字符组成的字符串的编码算法。 




6. 注意RSA加密填充方式

    之前以为上面操作就能实现rsa加解密，以为可以呢，但是遇到Android这边加密过的数据，服务器端死活解密不了，原来android系统的RSA实现是"RSA/None/NoPadding"，而标准JDK实现是"RSA/None/PKCS1Padding"，这造成了在android机上加密后无法在服务器上解密的原因，所以在实现的时候这个一定要注意这个问题。
  





7.  
  7.1 加密

		对原来为 明文 的文件或数据按 某种算法 进行处理，使其成为 不可读 的一段代码，通常称为 “密文”。通过这样的途径，来达到 保护数据 不被 非法人窃取、阅读的目的。

 7.2  解密 
        将该 编码信息 转化为其 原来数据 的过程。

7.3   对称加密
        在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。
        对于通信的双方，通过对称加密，可以很方便的将通信内容进行加密，然后进行安全传输，能够有效的防止信息在中途被中间人获取到原文。即使信息中途有被截获的可能，但只要密钥没有泄露，信息本身还是安全的。

 7.4   非对称加密
        
       
   

7.5  MD5算法
         MD5 用的是 哈希函数，不可逆  。  输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。


 7.6 SHA1算法

      SHA1 比 MD5 的 安全性更强，不可逆。 






 七:HTTPS加密原理
    HTTPS = HTTP + SSL .HTTPS 的加密就是在 SSL 中完成的。
     
    SSL/TLS协议的基本思路是：客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
                                

       SSL/TLS的作用:
         （1） 所有信息都是加密传播，第三方无法窃听。
         （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。
         （3） 配备身份证书，防止身份被冒充。


