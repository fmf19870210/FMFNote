 

https://juejin.im/post/5d6a8121e51d4561e6237193
https://juejin.im/post/5e5c5c52f265da575f4e7558#heading-195


 一:设计模式的目的:

    1.代码的可重复使用不用多次编写
    2. 可读性 代码规范 易于阅读理解
    3.  可扩展性 新增功能方便 易于维护
    4.  可靠性 新增功能对原来的功能没影响
    5.  高内聚 低耦合

 

 二:设计模式的七大原则

   1.单一职责原则:一个类只负责一个功能
   2. 接口隔离原则:将接口拆分为几个独立的接口,各自有自己的单独的功能.
   3. 依赖倒置倒转原则
   4. 里氏替换原则：继承的弊端:继承让类之间的耦合性增强,父类要进行修改,那么所有的子类都要跟着修改。 里氏要求子类尽量不要重写父类的方法
   5. 开闭原则： 最基础最重要的设计原则。当我们增加新的类或功能时,尽量不要对其他的类造成大的修改和变动。
   6. 迪米特原则
   7. 合成服用原则
    








一:定义


在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能；



 二:实现单例模式主要有如下几个关键点:
 构造函数不对外开放，一般为 private;
 通过一个静态方法或者枚举返回单例对象；
 确保单例类的对象有且只有一个，尤其是在多线程环境下；
 确保单例类对象在反序列化时不会被重新构建对象



 三:单例示例

 饿汉式
 单例模式是设计模式中比较简单的，只有一个单例类，没有其他层次结构与抽象。该模式需要确保该类只能生成一个对象，通常是该类需要消耗较多的资源或者没有多个实例的情况

 public class DaoManager {

       //饿汉式在声明的时候就已经初始化了实例对象
     private static DaoManager instance = new DaoManager();

     private DaoManager(){}

     public static DaoManager getInstance(){
         return instance;
     }
 }





懒汉模式
懒汉模式是声明了一个静态对象，并且在第一调用的时候进行初始化，而上面的饿汉纸则是在声明的时候已经初始化了


优点是单例只有再使用的时候进行初始化，在一定程度上节约了资源
缺点每次调用的时候 getInstance 都进行同步，造成不必要的开销




public class DaoManager2 {

    private static DaoManager2 instance;

    private DaoManager2(){}

    /**
     *  懒汉模式在第一次调用的时候才进行初始化,保证了线程安全
     *  synchronized 关键字    保证了在多线程情况下单例对象唯一性
     */
    public static synchronized DaoManager2 getInstance(){
        if (null == instance) {
            instance = new DaoManager2();
        }
        return instance;
    }
}







双层判断DCL的懒汉单例模式
第1个if 若单例对象已创建，则直接返回已创建的单例instance，无需再走synchronized 加锁操作判断  即返回return ourInstance,从而提高性能
第2个 if 防止多次重复创建单例对象


优点:能够在需要调用的时才初始化单例对象，又能保证线程安全， 又加了一层判断,且单例对象初始化后调用 instance 不进行同步锁， 节省开销。





 public class Singleton{
     // volatile保证了：1 instance在多线程并发的可见性 2 禁止instance在操作是的指令重排序
      private static  volatile   Singleton instance = null;;

       private Singleton(){}


       public static Singleton newInstance(){
          // 第1个if 若单例对象已创建，则直接返回已创建的单例instance，无需再走synchronized 加锁操作判断  即返回return ourInstance,从而提高性能,避免重复创建对象
           if(null==instance){
          // synchronized对Singleton加全局锁，保证每次只要一个线程创建实例      
        synchronized(Singleton.class){
            //   第2个 if 防止多次重复创建单例对象
             if(null==instance){
             instance = new Singleton();
             }

           }

          }
       return instance;

       }

}









静态内部类单例模式(最优)

DCL 虽然在一定程度上解决了资源消耗、多余的同步、线程安全等问题，但是，它还是在某些情况下出现失效的问题，这个问题被称为双重检查锁定失效，

		 原理分析:
		(1)getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance() 方法，取的都是同一个sInstance 对象，而不用去重新创建对象。
		(2)sInstance 在创建过程中又是如何保证线程安全的呢？
		 《深入理解JAVA虚拟机》中说:虚拟机会保证一个类的 () 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 () 方法，
		 其他线程都需要阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时很长的操作，
		 就可能造成多个线程阻塞 (需要注意的是，其他线程虽然会被阻塞，但如果执行 () 方法后，其他线程唤醒之后不会再次进入 () 方法。
		 同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。
		
		(3) 优点:静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。
		  缺点:不能传参
		   静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，
		  例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。


        clas Singleton{
           private static volatitle Singleton instance;
           //构造器私有化
	       private Singleton() {}
           //写一个静态内部类,该类中有一个静态属性 Singleton
           private static class SingletonInstance{
             private static final Singleton INSTACE = new Singleton();
            }      

           //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE
           public static synchronized Singleton getInstance() {
		
		    return SingletonInstance.INSTANCE;
             	}
           
            }

 






 工厂模式

一:简单工厂、工厂方法、抽象工厂的区别？
简单工厂模式SimpleFactoryPattern(静态工厂方法模式)：一个工厂方法创建不同类型的对象。
工厂方法模式Factory Method(多态性工厂模式)：一个具体的工厂类负责创建一个具体对象类型。
抽象工厂模式Abstract Factory：一个具体的工厂类负责创建一系列相关的对象。
  



二:为什么要用工厂模式

(1) 解耦 ：把对象的创建和使用的过程分开 
(2)降低代码重复: 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。
(3) 降低维护成本 ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。



简单工厂模式（SimpleFactoryPattern）(静态工厂方法模式)

    1.定义:  
    又叫简单工厂模式（SimpleFactoryPattern）（因为工厂类定义了一个静态方法）
     简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。

    2.简单工厂模式的组成:
      抽象产品（Product）         具体产品的父类    描述产品的公共接口
      具体产品（Concrete Product） 抽象产品的子类； 工厂类创建的目标类  描述生产的具体产品
      工厂（Creator）              被外界调用      根据传入不同参数从而创建不同具体产品类的实例对象

  
  	
   3. 优缺点
 优点:将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；
把初始化实例时的工作放到工厂类里进行，使代码更容易维护。 更符合面向对象的原则 & 面向接口编程，而不是面向实现编程。
   
 缺点:
 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类SimpleFactory的逻辑，这样就会造成简单工厂SimpleFactory逻辑过于复杂。
 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。




   4.demo代码：
     (1)创建抽象产品类 & 定义具体产品的公共接口；

          abstract class Product{
  		  	 
          		public abstract void Show();
			}



	(2)创建具体产品类（继承抽象产品类）Product  & 定义生产的具体产品；

			
			//具体产品类A
			class  ProductA extends  Product{
			
			    @Override
			    public void Show() {
			        System.out.println("生产出了产品A");
			    }
			}

			//具体产品类B
			class  ProductB extends  Product{
			
			    @Override
			    public void Show() {
			        System.out.println("生产出了产品C");
			    }
			}

				//具体产品类C
				class  ProductC extends  Product{
				
				    @Override
				    public void Show() {
				        System.out.println("生产出了产品C");
				    }
				}


 

	(3)创建简单工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；
	        
	 		  class  SimpleFactory {
					    public static Product Manufacture(String productName){
					//工厂类里用switch语句控制生产哪种商品；
					//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。
					        switch (productName){
					            case "A":
					                return new ProductA();
					
					            case "B":
					                return new ProductB();
					
					            case "C":
					                return new ProductC();
					
					            default:
					                return null;
					
					        }
					    }
					}








 

  (4) 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例

         //工厂产品生产流程
		public class SimpleFactoryPattern {
    		public static void main(String[] args){
       

        //客户要产品A
        try {
		//调用工厂类的静态方法 & 传入不同参数从而创建产品实例
           Product productA=  SimpleFactory.Manufacture("A");
                     productA.Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类A产品");
        }

        //客户要产品B
        try {
             Product productB=Factory.Manufacture("B");
                    productB.Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类B产品");
        }

        //客户要产品C
        try {
            Product productC=Factory.Manufacture("C");
                   productC.Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类C产品");
        }

        //客户要产品D
        try {
             Product productD=Factory.Manufacture("D");
                    productD.Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类D产品");
        }
    }
	 }















工厂方法模式（Factory Method）(一般项目中存在最多的就是这个模式)
一:定义:
 又称工厂模式、多态工厂模式。工厂方法模式 是为了解决 简单工厂模式(工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了"开放 - 关闭"原则)的缺点

 这里我们不再提供一个统一的工厂类来创建所有的对象(违背了"开放 - 关闭"原则),而是创建具体的不同的工厂生产具体的不同的产品(创建的每个对象都有一个与之对应的工厂)。


二:优缺点:
 工厂方法模式的作用:
  将具体创建产品子类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。这样在添加新的具体产品子类的时候就不修改工厂类逻辑而是添加新的具体的工厂子类，符合开放封闭原则，克服了简单工厂模式中缺点
 
   优点:

	更符合开-闭原则 新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可
	符合单一职责原则 每个具体工厂类只负责创建对应的产品
	使用静态工厂方法，可以形成基于继承的等级结构

缺点：
  
	 添加新产品时，除了增加新产品子类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
      一个具体工厂只能创建一种具体产品，将会极大的增加代码量


 三；UML图
   ![](https://upload-images.jianshu.io/upload_images/944365-27764702a32834a3.png?imageMogr2/auto-orient/strip|imageView2/2/w/848)
  


四:工厂方法模式的组成和步骤：

 抽象工厂类-->抽象产品类-->具体产品子类 -->具体工厂子类(生成具体产品)-->外界根据自己的需要调用不同的具体工厂子类获取具体的产品子类

(1)抽象工厂（Abstract Factory） 	具体工厂的父类 	描述具体工厂的公共接口

    创建抽象工厂类，定义具体工厂的公共接口；
    abstract class Factory{
    public abstract Product Manufacture();
	}




 
(2)具体工厂（Concrete Creator） 	抽象工厂的子类；被外界调用 	描述具体工厂；实现FactoryMethod工厂方法创建产品的实例
      创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；


			   //工厂A类 - 生产A类产品
			class  FactoryA extends Factory{
			    @Override
			    public Product Manufacture() {
			        return new ProductA();
			    }
			}
			
			//工厂B类 - 生产B类产品
			class  FactoryB extends Factory{
			    @Override
			    public Product Manufacture() {
			        return new ProductB();
			    }
			}








(3)抽象产品（AbstractProduct） 	具体产品的父类 	描述具体产品的公共接口
     创建抽象产品类 ，定义具体产品的公共接口；
	abstract class Product{
    public abstract void Show();
		}




(4)具体产品（Concrete Product） 	抽象产品的子类；工厂类创建的目标类 	描述生产的具体产品
       创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
       //具体产品A类
		class  ProductA extends  Product{
		    @Override
		    public void Show() {
		        System.out.println("生产出了具体产品A");
		    }
		}
		
		//具体产品B类
		class  ProductB extends  Product{
		
		    @Override
		    public void Show() {
		        System.out.println("生产出了具体产品B");
		    }
		}










(5)外界通过调用具体工厂子类的方法，从而获取 不同具体产品子类的实例对象
			   //生产工作流程
			public class FactoryPattern {
			    public static void main(String[] args){
			        //创建具体工厂A，生产具体产品A
			        FactoryA mFactoryA = new FactoryA();
			          mFactoryA.Manufacture().Show();
			
			        /创建具体工厂B，生产具体产品B
			        FactoryB mFactoryB = new FactoryB();
			        mFactoryB.Manufacture().Show();
			    }
			}










抽象工厂模式（Abstract Factory）
          
   一:定义:

        使用抽象的接口来创建一组系列的相关产品，而不需要知道或关心实际生产出的具体产品是什么
        抽象工厂中每个工厂可以创建多种类的产品,解决 每个工厂只能创建一类产品的缺点 (工厂方法模式的缺点)     



    二:抽象工厂的工厂和工厂方法中的工厂有什么区别呢？

     工厂方法中的工厂 : 其生产的是单一具体的产品。
     抽象工厂中的工厂:
      是将简单工厂模式和工厂模式的整合。
       是对简单工厂模式的进一步抽象    其生产的是一整套的产品（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的.

  二:UML图
  ![](https://upload-images.jianshu.io/upload_images/944365-5d5b65294ac19246.png?imageMogr2/auto-orient/strip|imageView2/2)

  ![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-6-3/62034363.jpg)
  

 三:  操作步骤:
     1.抽象工厂（AbstractFactory）角色 ：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。
     
      创建抽象工厂接口Factory
		  public interface Factory {
			    public Gun produceGun();
			    public Bullet produceBullet();
			}




     2.具体工厂类（ConreteFactory）角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。

       创建具体的工厂子类(实现抽象工厂接口Factory),生产一些列的具体产品子类 。 
                     
                  
        (1)创建具体工厂子类AK_Factory(实现抽象工厂接口Factory),这个具体工厂可以生产AK枪 AK子弹 等一些列军火产品 

          public class AK_Factory implements Factory{
							
							    @Override
							    public Gun produceGun() {
							        return new AK();
							    }
							
							    @Override
							    public Bullet produceBullet() {
							        return new AK_Bullet();
							    }
							
							}
							


      (2)创建具体工厂子类M4A1_Factory (实现抽象工厂接口Factory),这个具体工厂可以生产M4A1枪 M4A1子弹 等一些列军火产品    
   
           public class M4A1_Factory implements Factory{

				    @Override
				    public Gun produceGun() {
				        return new M4A1();
				    }
				
				    @Override
				    public Bullet produceBullet() {
				        return new M4A1_Bullet();
				    }
				
				}






     3.抽象产品（Abstract Product）角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。

          
     创建抽象产品接口(抽象类)：
     创建枪抽象产品
		   public interface Gun {
		    public void shooting();
		}

	  创建子弹抽象产品
	    public interface Bullet {
	    public void load();
	    }





      
     4.具体产品（Concrete Product）角色 ：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属   于同一产品族，这不同于工厂模式中的工厂只创建单一产品，我后面也会详解介绍到。
      
      
     创建抽象产品接口对应的实现具体产品子类：

     (1)AK枪具体产品子类 实现枪抽象产品接口Gun  
		        public class AK implements Gun{
		
		    @Override
		    public void shooting() {
		        System.out.println("shooting with AK");
		
		      }
		
		      }



     (2)M4A1枪具体产品子类 实现枪抽象产品接口Gun
          		 public class M4A1 implements Gun {
				
				    @Override
				    public void shooting() {
				        System.out.println("shooting with M4A1");
				
				    }
				
				}


       


     (3)AK子弹具体产品子类   实现  子弹抽象产品接口Bullet
          public class AK_Bullet implements Bullet {

			    @Override
			    public void load() {
			        System.out.println("Load bullets with AK");
			    }
			
			}





     (4)M4A1子弹具体产品子类 实现  子弹抽象产品接口Bullet 
         public class M4A1_Bullet implements Bullet {

				    @Override
				    public void load() {
				        System.out.println("Load bullets with M4A1");
				    }
				
				}   



   

     5.测试

          public class Test {

				    public static void main(String[] args) {  
				
				     Factory factory;
				     Gun gun;
				     Bullet bullet;
				
				     factory =new AK_Factory();//创建具体的AK工厂
				     bullet=factory.produceBullet(); //具体的AK工厂 生产具体的产品子弹
				     bullet.load(); //产品子弹 进行装填
				     gun=factory.produceGun();//具体的AK工厂 生产具体的产品枪
				     gun.shooting();  //产品枪 进行射击
				
				    }
				
				}




五:构建者模式   Builder Pattern (类似java的封装)  https://www.jianshu.com/p/be290ccea05a

     定义:隐藏创建复杂对象的过程。降低创建复杂对象的复杂度。将创建对象的过程和细节进行隐藏封装 & 复用
         你只需要传入参数,然后获取对象即可. 
   
         只需要获取这个 创建的复杂实例对象即可,不需要知道其内部实现的具体细节。
         (我们只需要会开车即可,不需要知道车的内部零件是如何构建组装的)


      优点:
      易于解耦：将产品本身与产品创建过程进行解耦，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象
      易于拓展维护:增加新的具体建造者无需修改原有类库的代码，易于拓展，符合“开闭原则“。


  构建过程:

		指挥者（Director）直接和客户（Client）进行需求沟通；
		沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）；
		 将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）；
		各个具体建造者负责进行产品部件的构建；
		最终构建成具体产品（Product）。


  步骤:

     步骤1：定义组装的过程（Builder）：组装电脑的过程   
           
			public  abstract class Builder {  
			
			//第一步：装CPU
			//声明为抽象方法，具体由子类实现 
			    public abstract void  BuildCPU()；
			
			//第二步：装主板
			//声明为抽象方法，具体由子类实现 
			    public abstract void BuildMainboard（）；
			
			//第三步：装硬盘
			//声明为抽象方法，具体由子类实现 
			    public abstract void BuildHD（）；
			
			//返回产品的方法：获得组装好的电脑
			    public abstract Computer GetComputer（）；
			}


    步骤2： 电脑城老板委派任务给装机人员（Director）
            public class Director{
                        //指挥装机人员组装电脑
                        public void Construct(Builder builder){
                                
                                 builder. BuildCPU();
                                 builder.BuildMainboard（）;
                                 builder. BuildHD（）;
                              }
                 }

    步骤3： 创建具体的建造者（ConcreteBuilder）:装机人员
    
           //装机人员1
			  public class ConcreteBuilder extend  Builder{
			    //创建产品实例
			    Computer computer = new Computer();
			
			    //组装产品
			    @Override
			    public void  BuildCPU(){  
			       computer.Add("组装CPU")
			    }  
			
			    @Override
			    public void  BuildMainboard（）{  
			       computer.Add("组装主板")
			    }  
			
			    @Override
			    public void  BuildHD（）{  
			       computer.Add("组装主板")
			    }  
			
			    //返回组装成功的电脑
			     @Override
			      public  Computer GetComputer（）{  
			      return computer
			    }  
			}



       步骤4： 定义具体产品类（Product）：电脑

		          public class Computer{
		    
		    //电脑组件的集合
		    private List<String> parts = new ArrayList<String>()；
		     
		    //用于将组件组装到电脑里
		    public void Add(String part){
		    parts.add(part);
				}
		    
		    public void Show(){
		          for (int i = 0;i<parts.size();i++){    
		          System.out.println(“组件”+parts.get(i)+“装好了”);
		          }
		          System.out.println(“电脑组装完成，请验收”);
		          
		 
					}
		
					}



       步骤5：客户端调用-小成到电脑城找老板买电脑
             
					public class Builder Pattern{
					  public static void main(String[] args){
					
					//逛了很久终于发现一家合适的电脑店
					//找到该店的老板和装机人员
					  Director director = new Director();
					  Builder builder = new ConcreteBuilder();
					
					//沟通需求后，老板叫装机人员去装电脑
					director.Construct(builder);
					
					//装完后，组装人员搬来组装好的电脑
					Computer computer = builder.GetComputer();
					//组装人员展示电脑给小成看
					computer.Show()；
					
					    }
					        
					}
					   




**六:代理模式**

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI5MjEzOTExMTYy)

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI5MjEzOTM4NzM2)


需要注意的有下面几点：

     1.用户只关心接口功能，而不在乎谁提供了功能。上图中接口是 Subject。
     2.接口真正实现者是上图的 RealSubject(工厂)，但是它不与用户直接接触，而是通过代理(中间代理商)。
     3.代理就是上图中的 Proxy(中间代理商)，由于它实现了 Subject 接口，所以它能够直接与用户接触。
     4.用户调用 Proxy 的时候，Proxy 内部调用了 RealSubject。所以，Proxy 是中介者，它可以增强 RealSubject 操作。



代理模式（Proxy Pattern）：静态代理  
 定义:给目标对象提供一个代理对象，  通过 代理对象 获取目标对象的引用。
     防止直接访问目标对象给系统带来的不必要复杂性。
     代理对象：起到中介作用，连接客户端和目标对象
![](https://upload-images.jianshu.io/upload_images/944365-3e4cc2f9c34a64cc.png)


 优点:
协调调用者和被调用者，降低了系统的耦合度
代理对象作为客户端和目标对象之间的中介，起到了保护目标对象的作用
 静态代理在编译期间 代理对象和被代理对象已经存在了。

 缺点:
由于在客户端和真实主题之间增加了代理对象，因此会造成请求的处理速度变慢；
实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度。
代理对象和目标对象 二者实现一样的接口,所以会有很多的代理类,如果接口增加方法,会增加代理对象和目标对象的维护复杂度。

 
 ![](https://upload-images.jianshu.io/upload_images/944365-6ab7f58ee0497fdd.png)


  案例:
   小成希望买一台最新的顶配Mac电脑,国内还没上，只有美国才有,寻找代购进行购买.
   代购（代理对象） 代替 我（真实对象） 去买Mac（间接访问的操作）
 
 

 使用步骤:

 步骤1： 创建抽象对象接口（Subject）：声明你（真实对象）需要让代购（代理对象）帮忙做的事买的东西（买Mac）
       public interface Subject {  
              public void buyMac();
			}

步骤2： 创建真实对象类（RealSubject）,即”我“(客户), 我要买台电脑

         public class RealSubject implement Subject{
		    @Override
		    public void buyMac() {  
		        System.out.println(”买一台Mac“);  
		    }  
		}



步骤3：创建代理对象类（Proxy），即”代购“(中间代理商)，并通过代理类创建真实对象实例并访问其方法

			  //代理类(中间商) 
             public class Proxy  implements Subject{
			    RealSubject realSubject; // 客户(被代理对象)
   
			    public Proxy( RealSubject realSubject) {
						super();
						this.realSubject = realSubject;
					}

               @Override
			    public void buyMac{
			      
			      //调用客户的方法，进行购买Mac
			      realSubject.buyMac（）；
			      //代理对象(中间商)Proxy额外做的操作
			      this.WrapMac()；
			    }
			
			     public void WrapMac(){
			      System.out.println(”用盒子包装好Mac“);  
			    }
			}




步骤4：客户端调用
       
		public class ProxyPattern {
		
		    public static void main(String[] args){
		       // 创建真实对象实例，即”我“(客户), 我要买台电脑
		 	      RealSubject realSubject = new RealSubject()；
		      // 创建 中间代理商对象  Proxy

              Subject proxy = new Proxy（realSubject）；
		           proxy.buyMac()；
		    }
		        
		}












 



代理模式（Proxy Pattern）：动态代理

为什么要使用动态代理:
 
 由于静态代理的缺点:1个静态代理 只代理服务1种类型的目标对象,若要代理服务多类型的目标对象，则需要为每种目标对象都实现一个静态代理对象，这样就会导致 静态代理对象量多、代码量大，从而导致代码复杂的问题。所以采用动态代理。所以，需要代理对象数量较多的情况下使用动态代理。
 

  
  
 


动态代理的实现原理/优点:
 (1)在使用时（调用目标对象方法时）才会动态创建动态代理类实例对象，不需要事先实例化.
 (2)不需要显式实现与目标对象类（RealSubject）相同的接口，而是将这种实现推迟到程序运行时由 JVM来实现
 (静态代理则是在代理类实现时就指定与目标对象类（RealSubject）相同的接口)

  (3)通过Java 反射机制的method.invoke（） 调用调用目标对象的方法。
  (4)只需要1个动态代理类就可以解决创建多个静态代理的问题，避免重复、多余代码.


 缺点:
(1)效率低,要先通过Java反射机制 从而 间接调用目标对象方法
 




动态代理与静态代理模式的区别

 ![](https://upload-images.jianshu.io/upload_images/944365-b577edcb96a1810e.png)

 静态代理:代码在编译前,代理对象和被代理对象 就已经存在;并且只能代理单一的目标对象。
 动态代理:在编译运行时,不需要显示代理对象和被，通过反射来实现,但是效率低,可以代理多个目标对象。



动态代理实现的简而言之一句话：

 通过JDK的API提供的代理类Proxy调用newProxyInstance()核心方法,创建一个动态代理实例对象,
 通过代理实例对象ProxyInstance()的通过反射机制invoke()方法, 调用目标代理被代理对象。
 




 案例:

小成 希望买一台最新的顶配 Mac 电脑；小何希望买一台 iPhone ，国内还没上，只有美国才有，寻找一个代购一起进行购买。
即1个代购（动态代理对象）(中间代理商)同时 代替 小成 （目标对象1）& 小何（目标对象2） 去买Mac（间接访问的操作）和iPhone。



 


使用步骤:

(1)声明 调用处理器类
    <-- 作用 -->
// 1.  生成 动态代理对象
// 2.  指定 代理对象运行目标对象方法时需要完成的 具体任务
// 注：需实现InvocationHandler接口 = 调用处理器 接口
// 所以称为 调用处理器类

 public class DynamicProxy implements InvocationHandler {

   
    // 作用：绑定关系，即关联到哪个接口（与具体的实现类绑定）的哪些方法将被调用时，执行invoke（）
    private Object proxyObject; // 目标对象(被代理对象)
     

      public Object getProxyInstance(Object proxyObject){
          this.proxyObject =proxyObject; //目标对象(被代理对象)    


            /*
               
             Proxy类 = 动态代理类的主类 
          Proxy.newProxyInstance（）作用：根据指定的类装载器、一组接口 & 调用处理器 生成动态代理类实例，并最终返回
          参数说明：
          参数1：当前目标对象被代理对象proxyObject的类加载器， 
          参数2：当前目标对象被代理对象的实现接口
          即要给目标对象提供一组什么接口。若提供了一组接口给它，那么该代理对象就默认实现了该接口，这样就能调用这组接口中的方法
          参数3：指定InvocationHandler对象。即动态代理对象在调用方法时，会关联到哪个InvocationHandler对象
      
          */
        return Proxy.newProxyInstance(proxyObject.getClass().getClassLoader(),
                proxyObject.getClass().getInterfaces(),this);
       

    }

   
           /*
           复写InvocationHandler接口的invoke（）
           动态代理对象调用目标对象的任何方法前，都会调用调用处理器类的invoke（）
             参数说明：
             参数1：动态代理对象（即哪个动态代理对象调用了method（）
             参数2：目标对象被调用的方法
             参数3：指定被调用方法的参数  
            */
		    @Override
		    public Object invoke(Object proxy, Method method, Object[] args)
		              throws Throwable {
		                System.out.println("代购出门了");
		                Object result = null;
		                // 通过Java反射机制调用目标对象被代理对象的方法
		                result = method.invoke(proxyObject, args);
		        return result;
		    }

		}






(2)声明目标对象类的抽象接口
			   public interface Subject {
			    // 定义目标对象的接口方法
			    // 代购物品
			    public  void buybuybuy();
			
			}








(3)声明目标对象类

   目标对象1 Buyer1.java
   
		// 小成，真正的想买Mac的对象 = 目标对象 = 被代理的对象
		// 实现抽象目标对象的接口
		public class Buyer1 implements Subject  {
		
		    @Override
		    public void buybuybuy() {
		        System.out.println("小成要买Mac");
		    }
		
		}







 目标对象2 Buyer2.java
			   // 小何，真正的想买iPhone的对象 = 目标对象 = 被代理的对象
			// 实现抽象目标对象的接口
			public class Buyer2 implements Subject  {
			
			    @Override
			    public void buybuybuy() {
			        System.out.println("小何要买iPhone");
			    }
			
			}





步骤4： 通过调用 动态代理对象的方法，从而调用目标对象的方法。 
 
 public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

       // 1. 创建目标对象对象(被代理对象)
        Buyer1 mBuyer1 = new Buyer1();

        // 2.给目标对象创建代理对象
        DynamicProxy dynamicProxy = new DynamicProxy();

        // 3. 创建动态代理类对象：通过调用处理器类对象getProxyInstance
          Subject buyer1_DynamicProxy = (Subject) dynamicProxy.getProxyInstance(mBuyer1);

        // 4. 通过调用动态代理对象方法从而调用目标对象方法
        // 实际上是调用了invoke（），再通过invoke（）里的反射机制调用目标对象的方法
        buyer1_DynamicProxy.buybuybuy();
        // 以上代购为小成代购Mac

        // 以下是代购为小何代购iPhone
        Buyer2 mBuyer2 = new Buyer2();
        Subject buyer2_DynamicProxy = (Subject) dynamicProxy.getProxyInstance(mBuyer2);
        buyer2_DynamicProxy.buybuybuy();
    }
}




(4)通过动态代理对象，调用目标对象的方法
 





 
动态代理语法 

1.动态代码涉及了一个非常重要的类 Proxy。正是通过 Proxy 的静态方法 newProxyInstance 才会动态创建代理。
 
 public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)

         参数: 
		    loader 自然是类加载器
		    interfaces 代码要用来代理的接口
		    h 一个 InvocationHandler 对象

  


2.InvocationHandler介绍:

  InvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。
  InvocationHandler 内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。
  
 

       public interface InvocationHandler {

           public Object invoke(Object proxy, Method method, Object[] args)throws Throwable;
       
        }


 
  3. InvocationHandler介绍的invoke方法的参数介绍:
     invoke(Object proxy, Method method, Object[] args)
     参数介绍:
     Object proxy  代理对象 
     Method method 代理对象调用的方法 
     Object[] args 调用的方法中的参数



安卓常用的设计模式:

 动态代理使用场景：Retrofit使用了动态代理极大地提升了扩展性和可维护性。



1.AlertDialog、Notification源码中使用了Bulider（建造者）模式完成参数的初始化：

2.日常开发的BaseActivity抽象工厂模式：

抽象的主题、具体的主题、抽象的UI元素和具体的UI元素之间的关系就是抽象工厂模式最好的体现.

3.Okhttp内部使用了责任链模式来完成每个Interceptor拦截器的调用：


4.RxJava的观察者模式： 

定义：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

ListView/RecyclerView的Adapter的notifyDataSetChanged方法、广播、事件总线机制。

观察者模式主要的作用就是对象解耦，将观察者与被观察者完全隔离，只依赖于Observer和Observable抽象。

ListView/RecyclerView/GridView的适配器模式：

适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

优点：

    更好的复用性：复用现有的功能。
    更好的扩展性：扩展现有的功能。







总结

    代理分为静态代理和动态代理两种。
    静态代理，代理类需要自己编写代码写成。
    动态代理，代理类通过 Proxy.newInstance() 方法生成。
    不管是静态代理还是动态代理，代理与被代理者都要实现两样接口，它们的实质是面向接口编程。
    静态代理和动态代理的区别是在于要不要开发者自己定义 Proxy 类。
    动态代理通过 Proxy 动态生成 proxy class，但是它也指定了一个 InvocationHandler 的实现类。
    代理模式本质上的目的是为了增强现有代码的功能。
 










观察者模式


   1.创建被观察者接口 

			 public interface Subject {
				
				public void registerObserver(Observer o);
				public void removeObserver(Observer o);
				public void notifyObservers();
			}



 2.创建被观察者实例对象,实现接口  Subject

				  public class WeatherData implements Subject {
					private float temperatrue;
					private float pressure;
					private float humidity;
					//观察者集合
					private ArrayList<Observer> observers;
					
					//加入新的第三方
				
					public WeatherData() {
						observers = new ArrayList<Observer>();
					}
				
					public float getTemperature() {
						return temperatrue;
					}
				
					public float getPressure() {
						return pressure;
					}
				
					public float getHumidity() {
						return humidity;
					}
				
					
				
					
				
					//注册一个观察者
					@Override
					public void registerObserver(Observer o) {
						// TODO Auto-generated method stub
						observers.add(o);
					}
				
					//移除一个观察者
					@Override
					public void removeObserver(Observer o) {
						// TODO Auto-generated method stub
						if(observers.contains(o)) {
							observers.remove(o);
						}
					}


                  //当数据有更新时，就调用 setData
					public void setData(float temperature, float pressure, float humidity) {
						this.temperatrue = temperature;
						this.pressure = pressure;
						this.humidity = humidity;
						//调用dataChange， 将最新的信息 推送给 接入方 currentConditions
						dataChange();
					}

                   public void dataChange() {
						//调用 接入方的 update
						notifyObservers();
					}
                  
                   //遍历所有的观察者，并通知
					@Override
					public void notifyObservers() {
						// TODO Auto-generated method stub
						for(int i = 0; i < observers.size(); i++) {
							observers.get(i).update(this.temperatrue, this.pressure, this.humidity);
						}
					}
				  }
				


3.创建观察者接口 
			   public interface Observer {
			
				public void update(float temperature, float pressure, float humidity);
			}

  
4.创建 多个观察者对象  分别都实现观察者接口Observer 
            public class CurrentConditions implements Observer {

				// 温度，气压，湿度
				private float temperature;
				private float pressure;
				private float humidity;
			
				// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式
				public void update(float temperature, float pressure, float humidity) {
					this.temperature = temperature;
					this.pressure = pressure;
					this.humidity = humidity;
					display();
				}
			
				// 显示
				public void display() {
					System.out.println("***Today mTemperature: " + temperature + "***");
					System.out.println("***Today mPressure: " + pressure + "***");
					System.out.println("***Today mHumidity: " + humidity + "***");
				}
			}

 

         public class BaiduSite implements Observer {

					// 温度，气压，湿度
					private float temperature;
					private float pressure;
					private float humidity;
				
					// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式
					public void update(float temperature, float pressure, float humidity) {
						this.temperature = temperature;
						this.pressure = pressure;
						this.humidity = humidity;
						display();
					}
				
					// 显示
					public void display() {
						System.out.println("===百度网站====");
						System.out.println("***百度网站 气温 : " + temperature + "***");
						System.out.println("***百度网站 气压: " + pressure + "***");
						System.out.println("***百度网站 湿度: " + humidity + "***");
					}
				
				}
 


 

 业务逻辑实现过程

				public class   Test{
				
				public static void main(String[] args) {
                 //创建一个被观察者对象
                  WeatherData weatherData = new WeatherData();
                //创建多个观察者对象
                CurrentConditions currentConditions = new CurrentConditions();
		       BaiduSite baiduSite = new BaiduSite();

                //将多个观察者对象 注册到被观察者对象里
					weatherData.registerObserver(currentConditions);
					weatherData.registerObserver(baiduSite);
 
                 //移除某个观察者对象  
                   //weatherData.removeObserver(currentConditions);

                 //被观察者数据发生变化,通知各个观察者更新数据
                   weatherData.setData(10f, 100f, 30.3f);
                   weatherData.setData(10f, 100f, 30.3f);
				}
				
				}











责任链设计模式 :U型

责任链顾名思义就是由一系列的负责者构成的一个链条，类似于工厂流水线，  
为请求创建了一个接收者对象的链.每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下 一个接收者，让下一个接受者处理请求,依此类推。

在责任链模式中，每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象
决定处理此请求。
客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的 情况下动态的重
新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象
所接受








//传送者 
abstract class Transmit{ 
//责任链中下一个传递者 
protected Transmit nextTransmit; 
boolean request(String msg); 
public void setNextTransmit(Transmit transmit){

nextTransmit = transmit; 
} 
}





public class Zero extends Transmit{
 public boolean request(String msg){ 
System.out.println("Zero接到纸条,会心一笑");
 boolean resp = nextTransmit.request(msg); 
return resp; 
} 
}




public class Alvin extends Transmit{ 
public boolean request(String msg){ 
System.out.println("Alvin接到纸条,伤心欲绝”);
 boolean resp = nextTransmit.request();
 return resp; 
} 
}
 
 


public class Lucy extends Transmit{ 
public boolean request(String msg){
 System.out.println("Lucy 王翠花阿姨接到纸条，兴高采烈"); 
return true; 
} 
}




private static Transmit getTransmits(){
 Transmit zero = new Zero(); 
Transmit alvin = new Alvin(); 
Lucy lucy = new Lucy(); 
zero.setNextTransmit(alvin);
 alvin.setNextTransmit(lucy); 
return errorLogger; 
}

 public static void main(String[] args) { 
Transmit transmit = getTransmits(); 
transmit.request("Hi,可以做我的女朋友吗？");

 }
 


  










