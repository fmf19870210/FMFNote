01 常量和变量
1.1 变量var
private var index: Int = 0          //定义具体的类型
private var a = 0                   //自动识别是int类型，通常不需要指定变量的类型
private var point: Point? = null    //定义对象 point是可空的
println(point?.x) //如果你不能确保point是否为空
println(point!!.x) //如果你能确保point一定不为空，否则point为空，这里会报运行时空指针

1.2 常量val(=java的final)
val s = "String"    //类型为String
val ll = 22L        //类型为Long
val d = 2.5         //类型为Double
val f = 5.5F        //类型为Float
val point = Point(20, 20)       //类型为Point对象
val intIndex: Int = 100  //int、long、float等类型仍然存在
val double:Double=100.toDouble()
val  long:Long=100.5F.toLong()  //数字类型(int、long、float)不会自动转型，必须要进行明确的类型转换



1.3  Any 和 Any?
 Any 类型是 Kotlin 所有非空类型的超类型 (类似java的object )
 如果把基本数据类型的值赋给 Any 类型的变量，则会自动装箱
val any: Any = 100
println(any.javaClass) //class java.lang.Integer



Any?   使变量可以存储包括 null 在内的所有可能的值

val any: Any? = null





02 函数[相当于java方法]

2.1 无返回值的函数Unit(可省略)(= Java 中的 void)
private fun yc(a: Int, b: Int) {
    println("sum of $a and $b is ${a + b}")
}


2.2 有返回值的函数
 var intparam:Int=getIntMeth(double,long)
private fun getIntMeth(double: Double, long: Long): Int {
        return   (double+long).toInt(); //转为int 类型
    }



03 构造方法
 实例化代码不需要new



04 空安全

4.0 不为空
  var a: String ="abc"  // 变量a 不能为空
  val l = a.length   //调用 a 的方法 不会 NPE 异常
   a = null // 编译错误, 变量a 不能为空




4.1   ?   (指定一个变量可null)
 可以加在任何类型的后面来表示这个类型的变量可以存储 null 引用
 Kotlin 对可空类型的显式支持有助于防止 NullPointerException 导致的异常问题
 编译器不允许不对可空变量做 null 判断就直接调用其属性，
 所以凡是 类型？ 的变量 在调用使用时 都要进行非空判断
Int?  Doubld?  Long?




         var b: String? = "abc"  //指定一个变量可null是通过在类型的最后增加一个问号？
            b = null
         val ll=b.length    //编译错误  当变量声明为可空时，在调用它的属性时无法通过编译
        val lll = b?.length  //使用安全操作符   ?.     先进行非空安全判断 可通过编译


var time: Long?=null
time!!.toFloat()
 time?.toInt()







4.2  ?.     !!.         ?=

 ?.    非空判断安全调用运算符(对某变量值非空判断,先进行判空，不为空,则方法或属性会被调用，否则直接返回 null )
       相当于java的非空判断 if(a!=null){a.foo();}

val  llll=b?.chars()   //if(a!=null){a.foo();}

fun check(name: String?): Boolean {
    //编译器不允许不对 name 做 null 检查就直接调用其属性
    if(name!=null){
        return name.isNotEmpty()
    }else{
        return false
    }

}



//以下两种写法是完全等同的
fun check(name: String?) {
    if (name != null) {
        println(name.toUpperCase())
    } else {
        println(null)
    }
}

fun check(name: String?) {
    println(name?.toUpperCase())
}









!!.
非空断言
非空断言用于把任何值转换为非空类型，如果对 null 值做非空断言，则会抛出异常
可以跳过限制检查通过编译，此时如果变量var为空会抛出空指针异常
      相当于java的 if(a!=null){a.foo();}else{throw new KotlinNullPointException();return;}
a!!.foo()

         var name:String?="ycc"
         checks(name) //3
         name=null
         checks(name) //KotlinNullPointerException


fun checks(name: String?) {
        println(name!!.length)
      }







?=  当前面的变量值不为空取前面的值，否则取后面的值(类似 java中三目运算 )



4.3   ?:
运算符接收两个运算数
左边的表达式没有成功，则使用右边的结果
 如果第一个运算数不为 null ，运算结果就是其运算结果值，如果第一个运算数为 null ，运算结果就是第二个运算数
 (类似三元表达式)

bannerBean是null,所以bannerBean?.title不会执行，所以最终a == "null"

var bannerBean : BannerBean? = null
var a = bannerBean?.title ?: "null"


//以下两种写法是完全等同的
fun check(name: String?) {
    if (name != null) {
        println(name)
    } else {
        println("yc")
    }
}

fun check(name: String?) {
    println(name ?: "yc")
}



4.4   let函数说明
let 函数可用于在表达式不为 null 时才执行指定代码块
fun check(name: String?) {
    name?.let {
        println(name)
    }
}



4.5
为可空类型定义扩展函数是一种更强大的处理 null 值的方式，
可以允许接收者为 null 的调用，并在该函数中处理 null ，
而不是在确保变量不为 null 之后再调用它的方法

val name: String? = null
println(name.isNullOrEmpty()) //true



@kotlin.internal.InlineOnly
public inline fun CharSequence?.isNullOrEmpty(): Boolean {
    contract {
        returns(false) implies (this@isNullOrEmpty != null)
    }

    return this == null || this.length == 0
}







05  类型检查


5.1  is 与 !is
运行时检查对象是否符合给定类型

类似java中的instantof关键字




        val strValue = "leavesC"
        parserType(strValue) //value is String , length : 7
        val longValue = 200L
        parserType(longValue)

  private fun parserType(strValue: Any) {
          when(strValue){
               is String -> println("value is String , ${strValue.length}")
              is Int -> println("value is Int ,${strValue.toLong()}")
              is Long ->println("value is Long")
              !is Long -> println("value !is Long")
              else -> println("unknown")

          }

     }



06  as  不安全的转换操作符

   一个变量的类型    as 转换为  另一个变量类型    二者的类型一样的
         val tempValue ="leavesC" as String
        println(tempValue.length)  //7
        val tempValue2 ="leavesC" as Int
        println(tempValue.length)  //会抛出异常 ClassCastException

  注意: null  不能进行类型的转换



07   as?  安全的转换操作符

val x = null
val y: String? = x as? String

